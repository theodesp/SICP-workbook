# Structure and Interpretation of Computer Programs workbook

This is my workbook and exercise solutions for the legendary [SICP Book](http://sarabander.github.io/sicp/html/.) using the DrRacket Scheme interpeter

All the workbooks are divided by chapters one on each folder.

### Chapters Completed

- [x] **Chapter 1**: Building Abstractions with Procedures
    - [x] : Exercise 1.1 Simple expressions
    - [x] : Exercise 1.2 Complex expression
    - [x] : Exercise 1.3 Sum of Squares
    - [x] : Exercise 1.4 Evaluate behavior
    - [x] : Exercise 1.5 Order of evaluation
    - [x] : Exercise 1.6 If predicate
    - [x] : Exercise 1.7 Good enough aproximation
    - [x] : Exercise 1.8 Newtons Method Sqrt
    - [x] : Exercise 1.9 Evaluate Substitution model
    - [x] : Exercise 1.10 Ackermann’s function
    - [x] : Exercise 1.11 Compute function using iteration
    - [x] : Exercise 1.12 Pascals Triangle
    - [x] : Exercise 1.13 Prove Fibonacci closest integer
    - [x] : Exercise 1.14 Draw illustrative process
    - [x] : Exercise 1.15 Find order of growth
    - [x] : Exercise 1.16 Fast iterative exponental calc
    - [x] : Exercise 1.17 Faster exponental calc
    - [x] : Exercise 1.18 Doubling of integers
    - [x] : Exercise 1.19 Faster Fibonacci
    - [x] : Exercise 1.20 Count GCD operations
    - [x] : Exercise 1.21 Find smallest divisor
    - [x] : Exercise 1.22 Time functions
    - [x] : Exercise 1.23 Time functions
    - [x] : Exercise 1.24 Time functions
    - [x] : Exercise 1.25 Order of growth changed
    - [x] : Exercise 1.26 Order of growth changed
    - [x] : Exercise 1.27 Prove Carmichael exist
    - [x] : Exercise 1.28 Miller-Rabin test
    - [x] : Exercise 1.29 Simpson’s Rule
    - [x] : Exercise 1.30 Find approximations to π
    - [x] : Exercise 1.31 Find approximations to π
    - [x] : Exercise 1.32 Construct accumulate function
    - [x] : Exercise 1.33 Construct filtered-accumulate function
    - [x] : Exercise 1.34 Evaluate recursive expression
    - [x] : Exercise 1.35 Show golden ratios fixed point
    - [x] : Exercise 1.36 Calculate fixed point of expression
    - [x] : Exercise 1.37 Infinite continued fraction
    - [x] : Exercise 1.38 Eulers approximation of e
    - [x] : Exercise 1.39 Lamberts approximation of tangent
    - [x] : Exercise 1.40 Newton's method using cubic func
    - [x] : Exercise 1.41 Double Double func
    - [x] : Exercise 1.42 Compose Func
    - [x] : Exercise 1.43 Repeated Func
    - [x] : Exercise 1.46 Iterative improvement Func
    
- [ ] **Chapter 2**: Building Abstractions with Data
    - [x] : Exercise 2.1 Better version of make-rat
    - [x] : Exercise 2.2 Provide make-segment 
    - [x] : Exercise 2.4 Cdr alternative
    - [x] : Exercise 2.5 Cons/Car/Cdr with exp numbers
    - [x] : Exercise 2.6 Church Numbers
    - [x] : Exercise 2.7 Interval Selectors
    - [x] : Exercise 2.8 Sub-interval
    - [x] : Exercise 2.9 Width
    - [x] : Exercise 2.10 Safe div-interval
    - [x] : Exercise 2.11 Mul interval fast
    - [x] : Exercise 2.12 Percent
    - [x] : Exercise 2.14 Invalid computations
	- [x] : Exercise 2.17 Last pair
	- [x] : Exercise 2.18 List reverse
    - [x] : Exercise 2.19 Locale Coins
    - [x] : Exercise 2.20 Same Parity
	- [x] : Exercise 2.21 Square-list
	- [x] : Exercise 2.22 Square-list issue
	- [x] : Exercise 2.23 for-each
	- [x] : Exercise 2.24 List tree evaluation
	- [x] : Exercise 2.25 Car/cdrs
	- [x] : Exercise 2.26 Evaluate list/append/cons
	- [x] : Exercise 2.28 deep-reverse
	- [x] : Exercise 2.29 total-weight of mobile tree
	- [x] : Exercise 2.30 square-map
	- [x] : Exercise 2.31 tree-map
	- [x] : Exercise 2.32 subsets
	- [x] : Exercise 2.33 map, length, append
	- [x] : Exercise 2.34 Horner
	- [x] : Exercise 2.35 count-leaves2
    
- [ ] **Chapter 3**: Modularity, Objects, and State
- [ ] **Chapter 4**: Metalinguistic Abstraction
- [ ] **Chapter 5**: Computing with Register Machines
