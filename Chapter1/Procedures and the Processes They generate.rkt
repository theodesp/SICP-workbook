#lang scheme/base

; Factorial recur
(define (factorial n)
  (cond ((= n 1) 1)
        (else (* n (factorial (- n 1))))))

(factorial 5)

; Factorial iter
(define (factorial2 n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
(cond ((> counter max-count) product)
      (else (fact-iter (* counter product)
                       (+ counter 1)
                       max-count))))

(factorial2 5)

; Exercise 1.9: Each of the following two procedures defines a
; method for adding two positive integers in terms of the procedures inc, which increments
; its argument by 1, and dec, which decrements its argument by 1.


;(define (+ a b)
;  (if (= a 0) 
;      b 
;      (inc (+ (dec a) b))))

; (+ 4 5)
; (inc (+ 3 5))
; (inc (inc (+ 2 5)))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9
; Recursive

;(define (+ a b)
;  (if (= a 0) 
;      b 
;      (+ (dec a) (inc b))))
;(+ 4 5)
;(+ 3 6)
;(+ 2 7)
;(+ 1 8)
;(+ 0 9)
;9
; Iterative

; Exercise 1.10: The following procedure
; computes a mathematical function called Ackermann’s function.


(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(A 1 10) ; 1024
(A 2 4) ; 65536
(A 3 3) ; 65536

; Fibonacci numbers
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

(fib 10)

(define (fib2 n) 
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (cond ((= count 0) b)
      (else (fib-iter (+ a b) a (- count 1)))))

(fib2 10)

; Exercise 1.11: A function ff is defined by the rule that f(n)=nf(n)=n
; if n<3n<3 and f(n)=f(n-1)+2f(n-2)+3f(n-3)f(n)=f(n-1)+2f(n-2)+3f(n-3)
; if n≥3n≥3. Write a procedure that computes ff by means of a recursive
; process. Write a procedure that computes ff by means of an iterative
; process.

(define (ff n)
  (cond ((< n 3) n)
        (else (+ (ff (- n 1)) (* 2 (ff (- n 2))) (* 3 (ff (- n 3)))))
        ))

(ff 4) ; 59

; iterative
(define (ff2 n)
  (cond ((< n 3) n)
        (else (ff-iter 0 1 2 n))))

(define (ff-iter a b c count)
  (cond ((= count 0) c)
      (else (ff-iter b c  (+ (* 3 a) (* 2 b) c) (- count 2)))))
(ff2 4)

; Exercise 1.12:Write a procedure that computes elements of Pascal’s triangle
; by means of a recursive process

; Print the value of the pascal triacle at row and column
(define (pascal row column)
  (cond ((or (= row column) (= 1 column)) 1)
        (else (+ (pascal (- row 1) (- column 1))
                 (pascal (- row 1) column)))))
(pascal 4 2)

; Exercise 1.13: Prove that Fib(n)Fib(n) is the closest integer
; to φn/5⎯⎯√φn/5, where φ=(1+5⎯⎯√)/2φ=(1+5)/2.
; Hint: Let ψ=(1-5⎯⎯√)/2ψ=(1-5)/2.
; Use induction and the definition of the Fibonacci numbers
; (see 1.2.2) to prove that Fib(n)=(φn-ψn)/5⎯⎯√Fib(n)=(φn-ψn)/5.

; Base case let φ=(1+5⎯⎯√)/2 and ψ=(1-5⎯⎯√)/2, φ – ψ = 1, φ * ψ = 1
; and φ, ψ  are the two roots of x^2=x+1 then
; If x^2=x+1 then x^n = fib(n) x + fib(n-1) for n>0.
;
;  from the formula above, we have
;  φ^n = fib(n)φ + fib(n-1)(A)
; (-ψ)^n =  fib(n) (-ψ) + fib(n-1) (B)
; Subtracting (B) from (A) gives:
; φ^n - (-ψ)n = fib(n)(φ - (-ψ))
; then fib(n) = φ^n - (-ψ)^n/φ -(-ψ)


; Exercise 1.14: Draw the tree illustrating the process
; generated by the count-change procedure of 1.2.2 in making
; change for 11 cents. What are the orders of growth of the
; space and number of steps
; used by this process as the amount to be changed increases?

; (count-change 10)
; ->   (cc 10 5)
; ->   (+ (cc 10 (4)) (cc (- 10 25) 5)
; ->   (+ ((+ (cc 10 (3)) 1 1)
; ->   (+ ((+ ((+ (cc 10 (2)) 1 1 1)
; ->   (+ 1 1 1 1)
; -> 4
;

(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))

; 1>How many times is the procedure p applied when
; (sine 12.15) is evaluated?

(sine 12.15)
; (p (sine 4.05))
; (p (p (sine 1.3499999999999999))
; (p (p (p 0.44999999999999996))
; (p (p (p (p 0.15))
; (p (p (p (p (p 0.049))
; (p (p (p (p (p (p 0.016666666666666666))
; (p (p (p (p (p (p 0.016666666666666666))
; (p (p (p (p (p (p (p 0.005555555555555556))
; 7 times or \lim _{x\to 7}\left(\frac{12.15}{3^x}\right)

; 1.2.4 Exponentiation

(define (expt b n)
  (if (= n 0) 
      1 
      (* b (expt b (- n 1)))))
(expt 2 2)

(define (expt2 b n) 
  (expt-iter b n 1))

; Iterative
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))

; b^n=(b^n/2)^2 if n is even
; b^n=b⋅b^n−1 ,if n is odd.

(define (fast-expt b n) ; The process has Θ(logn) growth
  (cond ((= n 0) 
         1)
        ((even? n) 
         (square (fast-expt b (/ n 2))))
        (else 
         (* b (fast-expt b (- n 1))))))

(define (even? n)
  (= (remainder n 2) 0))

(define (square n)
  (* n n))

(fast-expt 4 2)

; Exercise 1.16: Design a procedure that evolves an iterative
; exponentiation process that uses successive squaring and uses
; a logarithmic number of steps, as does fast-expt.
; (Hint: Using the observation that
; (bn/2)2=(b2)n/2(bn/2)2=(b2)n/2 , keep, along with the exponent
; nn and the base bb, an additional state variable aa,
; and define the state transformation in such a way that
; the product abnabn is unchanged from state to state.
; At the beginning of the process aa is taken to be 1,
; and the answer is given by the value of aa at the end of the process.
; In general, the technique of defining an invariant quantity that
; remains unchanged from state to state is a powerful way to think
; about the design of iterative algorithms.)

(define (fast-expt2 a b)
  (fast-expt-iter a b 1))

(define (fast-expt-iter a b multiplier)
  (cond ((= b 0)
         1)
        ((<=  b 1)
         (* a multiplier))
        ((even? b) 
         (fast-expt-iter (square a) (/ b 2) multiplier))
        (else 
         (fast-expt-iter (square a) (/ (- b 1) 2) (* a multiplier))))
  )

(fast-expt2 4 2)

; Exercise 1.17-1.18:  Using these, design a multiplication procedure analogous
; to fast-expt that uses a logarithmic number of steps.

(define (double x)
  (* x 2))
(define (halve x)
  (/ x 2))

(define (mul a b)
  (mul-iter a b 0))

(define (mul-iter a b result)
  (cond ((= b 0)
        result)
        ((even? b) 
         (mul-iter (double a) (halve b) result))
         (else
          (mul-iter a (- b 1) (+ a result)))))

(mul 6 6) ; 36

; ;1.2.5Greatest Common Divisors

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

; Exercise 1.20:
; Using the substitution method (for normal order), illustrate the process generated
; in evaluating (gcd 206 40) and indicate the remainder operations that are actually
; performed. How many remainder operations are actually performed in the normal-order
; evaluation of (gcd 206 40)? In the applicative-order evaluation?

; (gcd 206 40)
; (gcd 40 6)
; (gcd 6 4)
; (gcd 4 2)
; (gcd 2 0)
; 5 steps Applicative

; 1.2.6Example: Testing for Primality

(define (divides? a b)
  (= (remainder b a) 0))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  ; Return the number if the square of test is bigger
  (cond ((> (square test-divisor) n)
         n)
        ; Test if it test devides n
        ((divides? test-divisor n) 
         test-divisor)
        ; Otherwise inc test and run the tests again
        (else (find-divisor 
               n 
               (+ test-divisor 1)))))

; A number is prime iff the smallest divisor is it self or 1
(define (prime? n)
  (= n (smallest-divisor n)))

;A procedure that computes the exponential of a number modulo another number:
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base (expmod base (- exp 1) m))
          m))))

; Fermats test
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

; Probabilistic test n times if the number is Prime
(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n) 
         (fast-prime? n (- times 1)))
        (else #f)))

; Exercise 1.21: Use the smallest-divisor procedure
; to find the smallest divisor of each of the following
; numbers: 199, 1999, 19999.

(smallest-divisor 199) ; 199
(smallest-divisor 1999); 1999
(smallest-divisor 19999); 7

; Exercise 1.22:
; Using this procedure, write a procedure search-for-primes that
; checks the primality of consecutive odd integers in a specified range.
; Use your procedure to find the three smallest primes larger than 1000;
; larger than 10,000;
; larger than 100,000;
; larger than 1,000,000.


(define (timed-prime-test n)
  (newline)
  (display n)
  (time prime? n))

; Iterative call to print amount of primes above n
(define (search-for-primes n amount)
  (cond ((= amount 0) #t)
        ((prime? n)(display n)(newline)
         (search-for-primes (+ n 1) (- amount 1)))
        (else
         (search-for-primes (+ n 1) amount)
         ))
  )

; Exercise 1.23: define a procedure next that returns 3
; if its input is equal to 2 and otherwise returns its input plus 2.
; Modify the smallest-divisor procedure to use (next test-divisor)
; instead of (+ test-divisor 1). 

(define (next n)
  (cond ((= n 2)
         3)
        (else (+ n 2))
        )
  )

; Exercise 1.26:By writing the procedure like that,
; you have transformed
; the Θ(log⁡n) process into a Θ(n) process.” Explain.


(define (expmod2 base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder 
          (* (expmod2 base (/ exp 2) m)
             (expmod2 base (/ exp 2) m))
          m))
        (else
         (remainder 
          (* base 
             (expmod2 base (- exp 1) m))
          m))))

; Its Θ(n) as now the order of evaluation changes
; Now we have to calculate expmod2  expmod2 twice
; if exp is even so that with the normal order of
; evaluation will accumulate over Θ(n)

; Exercise 1.27: Demonstrate that the Carmichael
; numbers listed in Footnote 47 really do fool the
; Fermat test. That is, write a procedure that takes
; an integer nn and tests whether anan is congruent
; to aa modulo nn for every a<n, and try your
; procedure on the given Carmichael numbers.

(define (is-congruent n)
  (is-congruent-iter n 2))

(define (is-congruent-iter number curr)
  (cond ((= curr number) #t)
        ((= (expmod curr number number) curr)
         (is-congruent-iter number (+ curr 1)))
        (else #f))
  )

(is-congruent 561) ; true!

; Exercise 1.28: Modify the expmod procedure to signal
; if it discovers a nontrivial square root of 1,
; and use this to implement the Miller-Rabin test
; with a procedure analogous to fermat-test. 

(define (miller-prime? n times)
  (cond ((= times 0) #t)
        ((miller-rabin-test n) 
         (miller-prime? n (- times 1)))
        (else #f)))

(define (miller-rabin-test n)
  (define (try-it a)
    (define (check-it x)
      (and (not (= x 0)) (= x 1)))
    (check-it (miller-rabin-expmod a (- n 1) n)))
  (try-it (+ 1 (random (remainder (- n 1) 4294967087)))))

(define (miller-rabin-expmod base exp m)
  (define (squaremod-with-check x)
    (define (check-nontrivial-sqrt1 x square)
      (if (and (= square 1)
               (not (= x 1))
               (not (= x (- m 1))))
          0
          square))
    (check-nontrivial-sqrt1 x (remainder (expt x 2) m)))
  (cond ((= exp 0) 1)
        ((even? exp)
         (squaremod-with-check
                      (miller-rabin-expmod base (/ exp 2) m)))
        (else
         (remainder 
          (* base (miller-rabin-expmod base (- exp 1) m))
          m))))

(miller-prime? 1999 100)